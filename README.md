# Лабораторная работа №7.
Тема работы: Преобразование и анализ кода с использованием Clang и LLVM.  
Цель работы: Познакомиться с инструментами Clang и LLVM, научиться собирать AST и IR-промежуточное представление кода на C/C++, а также извлекать базовую информацию о программе.  
Задание: 
1. Установить Clang и LLVM;
2. Скомпилировать простой C-файл с использованием clang и получить его: абстрактное синтаксическое дерево (AST), промежуточное представление LLVM IR;
3. Использовать opt для применения базовой комплексной оптимизации (например, О2);
4. Построить граф потока управления (CFG) для оптимизированной программы;
5. Проанализировать результат, сделать выводы и ответить на контрольные вопросы.

# Ход работы
## 1. Установка и подготовка среды
Работа выполнялась в среде Ubuntu 24.10. Установлены следующие инструменты:
- clang - компилятор языка C/C++;
- llvm - инструменты анализа и оптимизации кода;
- opt - инструмент для работы с LLVM IR и применения оптимизаций;
- Graphviz - инструмент для визуализации кода.    

Команда для установки: sudo apt install clang llvm
![image](https://github.com/user-attachments/assets/4c642f06-289b-456c-b21f-8ba57135acfb)

## 2. Исходный код.
```C++
#include <stdio.h>
int square(int x) {
 return x * x;
}

int main() {
 int a = 5;
 int b = square(a);
 printf("%d\n", b);
 return 0;
}
```
Сохранён в файле main.c

## 3. Получение AST
Команда: clang -Xclang -ast-dump -fsyntax-only main.c
![image](https://github.com/user-attachments/assets/1ce13c81-1f00-4438-9e9b-b0deddd1e010)
Функция square принята, содержит параметр x и возвращает x * x

## 4. Генерация LLVM IR
Команда: clang -S -emit-llvm main.c -o main.ll
![image](https://github.com/user-attachments/assets/6c3533b4-bcca-43b9-8829-da89e32e1832)

## 5. Оптимизация IR
Команда: clang -O0 -S -emit-llvm main.c -o main_O0.ll  
Стоит отметить, что в файле с IR до оптимизации:
- Все переменные (a, b, x.addr) размещены в памяти через alloca;
- Множество операций load и store;
- square вызывается как отдельная функция.    

![image](https://github.com/user-attachments/assets/bddb9d66-8ff1-41a0-a8db-d96b9c20ac9d)  

Команда: clang -O2 -S -emit-llvm main.c -o main_O2.ll  
Команда -O2 - комплексная оптимизация среднего уровня. Она применяет более 30 различных оптимизаций:
- -inline – встраивание небольших функций (встраивает square в main, если она вызывается один раз);
- -constprop – подставит значение square(5) → 25, если функция встроена и всё известно на этапе компиляции;
- -mem2reg – перевод переменных из памяти в регистры (SSA);
- -instcombine – объединение и упрощение инструкций (упростит арифметику, например x * x может быть преобразовано в shl при x = 2^n);
- -simplifycfg – оптимизирует структуру блоков (Упростит граф управления, если после inlining останутся лишние блоки);
- -reassociate, -gvn, -sroa, -dce и другие.

В файле с IR после оптимизации:
- Вся функция square исчезла – она была встроена (-inline) и затем вычислена (оптимизация -constprop);
- Никаких переменных, alloca, store, load – всё удалено (оптимизации -mem2reg, -dce);
- Остался только вызов printf(25).    

![image](https://github.com/user-attachments/assets/9f7a4b37-765e-43be-89d1-9fc562cee8b7)  

Команда: diff main_O0.ll main_O2.ll (Сравнение двух файлов):
![image](https://github.com/user-attachments/assets/ce71fdf9-2009-40cd-b191-f56bfac9d43f)  
Стоит отметить, что после оптимизации произошли следующие изменения:  
- Переменные типа alloca были удалены;
- Код переведён в SSA-форму;
- Оптимизация улучшила читаемость и упростила поток управления.    

## 6. Граф потока управления программы
Команда для генерации оптимизированного LLVM IR: clang -O2 -S -emit-llvm main.c -o main.ll  
Команда для генерации .dot-файлов CFG для функций: opt -passes="dot-cfg" -disable-output main.ll  
![image](https://github.com/user-attachments/assets/ff7bb1b1-fa50-4536-82cf-4033b3fc000b)  
Эта команда создаст DOT-файлы: .main.dot – для функции main; .square.dot – для square, если она не была удалена оптимизацией.  
Команда для установки библиотеки Graphviz: sudo apt install graphviz  
Команды для преобразования файлов с расширением .dot в .png с помощью Graphviz:
- dot -Tpng .main.dot -o cfg_main.png
- dot -Tpng .square.dot -o cfg_square.png    

![image](https://github.com/user-attachments/assets/6d8ee384-b94b-4d31-bcca-0ac41838fb15)
- Команды для просмотра файлов с CGF:
- xdg-open cfg_main.png    
![image](https://github.com/user-attachments/assets/c8a8bc4a-4eca-4f7f-bfb8-9cf59f8ae403)
- xdg-open cfg_square.png    
![image](https://github.com/user-attachments/assets/071f939c-9bcf-474d-b7eb-e688ee80090a)    

Стоит отметить, что в LLVM каждый граф потока управления (CFG) строится на уровне функции, поскольку структура управления всегда локальна для тела функции. Для получения полного представления о программе, нужно построить CFG для всех функций и анализировать их совокупность. Автоматическое объединение всех CFG в один граф не предусмотрено в LLVM по умолчанию.  

**Выводы**  
- С помощью Clang можно получить полную структуру AST и IR, а также CGF;
- LLVM предоставляет гибкие инструменты анализа и оптимизации;
- Промежуточное представление кода удобно для написания компиляторных трансформаций.    

## Контрольные вопросы:
1. Что такое Clang, и какова его роль в процессе компиляции программ?  
Clang — это компилятор для языков C, C++, Objective-C. Он анализирует исходный код, строит абстрактное синтаксическое дерево (AST), проверяет синтаксис и семантику, и преобразует код в LLVM IR — промежуточное представление, передаваемое дальше в LLVM.  
Роль Clang — разобрать исходный код и подготовить его для дальнейшей трансформации и оптимизации.  
2. Что представляет собой LLVM и как он используется в современных компиляторах?  
LLVM — это модульная компиляторная инфраструктура. В ней реализованы инструменты для генерации, анализа и оптимизации кода на промежуточном уровне (IR).  
3. Чем отличается абстрактное синтаксическое дерево (AST) от промежуточного представления LLVM IR?  
Абстрактное синтаксическое дерево (AST) и LLVM IR служат разным целям. AST — это высокоуровневая структура, которая точно отражает логику исходного кода, его иерархию и синтаксис. Она используется на ранних этапах компиляции для анализа программы. В отличие от этого, LLVM IR — это низкоуровневое, более универсальное представление, в котором уже не остаётся особенностей конкретного языка. Оно ближе к машинному коду и ориентировано на оптимизации и генерацию исполняемых инструкций.  
4. Для чего необходимо промежуточное представление (IR) в процессе компиляции?  
Промежуточное представление (IR) нужно для того, чтобы отделить обработку языка от генерации кода. Оно позволяет применять коду оптимизации, которые будут одинаково работать независимо от исходного языка или целевой платформы. Это значительно упрощает архитектуру компилятора и делает его модульным: можно использовать один и тот же оптимизатор и генератор кода для разных языков.  
5. Что делает инструкция alloc в LLVM IR, и зачем она используется в функциях?  
Инструкция alloca в LLVM IR используется для выделения памяти на стеке внутри функции. Она создаёт область памяти, которая будет автоматически очищена после завершения функции. Обычно alloca применяется для хранения локальных переменных, к которым далее можно обращаться через указатель.  
6. Зачем нужна оптимизация кода в компиляторе, и какие основные цели она преследует?  
Оптимизация кода в компиляторе направлена на повышение эффективности работы программы. Она помогает сократить время выполнения, уменьшить объём используемой памяти, сократить размер исполняемого файла и избавиться от ненужного кода. Без оптимизации сгенерированный код был бы значительно менее эффективным и производительным.  
7. Что такое SSA-форма и почему она важно при оптимизации программ?  
SSA-форма, или форма статического одиночного присваивания, означает, что каждой переменной в программе присваивается значение только один раз. Если переменная изменяется, создаётся её новая версия. Это сильно упрощает анализ зависимостей между переменными и делает возможными более агрессивные и точные оптимизации. SSA является стандартной формой представления программ в большинстве современных оптимизаторов.
8. Что такое граф потока управления (CFG) и как он помогает анализировать поведение программы?  
Граф потока управления (CFG) — это структура, которая показывает, как может передаваться управление между различными частями программы. Каждый узел графа соответствует базовому блоку кода (то есть последовательности инструкций без ветвлений), а рёбра показывают возможные переходы. CFG используется для анализа логики выполнения, распознавания циклов, ветвлений и определения доступности кода.  
9. Как устроено представление арифметических операций в LLVM IR (например, умножение, сложение)?  
Арифметические операции в LLVM IR представляются как простые инструкции, каждая из которых оперирует с переменными SSA. Например, сложение, вычитание или умножение задаются инструкциями add, sub, mul и принимают два аргумента. Результат всегда сохраняется в новой переменной. Это делает каждую операцию простой и понятной для анализа и оптимизации.  
10. Почему функции в LLVM IR обычно представляют собой отдельные единицы анализа и оптимизации?  
Функции в LLVM IR считаются отдельными единицами, потому что они представляют собой логически изолированные блоки с чёткими границами, входами и выходами. Благодаря этому компилятор может оптимизировать каждую функцию отдельно, не затрагивая остальной код. Это упрощает реализацию локальных оптимизаций и улучшает масштабируемость компилятора.  
11. Что происходит с функцией в LLVM IR, если она вызывается один раз и очень короткая?  
Если функция в LLVM IR вызывается только один раз и имеет короткое тело, компилятор может решить встроить её содержимое в вызывающий код. Это называется инлайнингом. Такая замена помогает избавиться от накладных расходов на вызов и часто даёт возможность провести дополнительные оптимизации после внедрения тела функции.  
12. Какие преимущества даёт использование IR и CFG для автоматических оптимизаций по сравнению с анализом исходного текста на C?  
Использование IR и CFG даёт компилятору гораздо больше возможностей для автоматических оптимизаций, чем анализ исходного кода на языке вроде C. Исходный код содержит множество синтаксических и семантических особенностей, усложняющих анализ. В IR эти сложности устранены: остаётся чистая логика, выраженная в простых и однозначных инструкциях. CFG позволяет точно понять, как будет выполняться программа, где есть ветвления, где — мёртвый код, и какие блоки можно объединить или упростить. Всё это невозможно сделать столь эффективно, анализируя текст программы напрямую.  

## Дополнительное задание:
**Вариант 7. Объявление массива символов с инициализацией строковой константой на языке C**  
Задание: Создайте char msg\[\] = "Hello"; и выведите msg\[1\]. Посмотрите, как Clang хранит строку в IR и как обращается к символам.  
Исходный код программы в файле dop.c:  
```
#include <stdio.h>

int main() {
    char msg[] = "Hello";
    printf("%c\n", msg[1]);
    return 0;
}
```  
Генерация LLVM IR:  
![image](https://github.com/user-attachments/assets/376100c9-bd1e-4f79-a244-77607b69d0cc)  
Здесь мы видим следующее:  
1. Хранение строки "Hello"  
```
@__const.main.msg = private unnamed_addr constant [6 x i8] c"Hello\00", align 1
```
Это глобальная константа - массив из 6 байт, содержащий строку "Hello" и завершающий нулевой байт(\00). Ключевое слово constant указывает, что содержимое не будет изменяться. Она втоматически создана компилятором при инициализации массива msg[] = "Hello".  

2. Создание массива msg  
```
%2 = alloca [6 x i8], align 1
```
Здесь alloca выделяет в стеке массив из 6 байт, предназначенных для msg. То есть msg хранится локально в стеке, а не как ссылка на глобальную строку. Это соответствует семантике C, так как char msg[] = "Hello"; создаёт именно копию строки, а не указатель.  
3. Копирование строки в msg  
```
call void @llvm.memcpy.p0.p0.i64(ptr align 1 %2, ptr align 1 @__const.main.msg, i64 6, i1 false)
```
Инструкция llvm.memcpy копирует 6 байт из глобальной константы в локальный массив. Это шаг инициализации массива msg.  
4. Обращение к msg\[1\]  
```
%3 = getelementptr inbounds [6 x i8], ptr %2, i64 0, i64 1
%4 = load i8, ptr %3, align 1
```
Сначала getelementptr вычисляет адрес второго элемента массива. %2 — это msg, i64 0 — смещение по массиву, i64 1 — смещение по элементу. То есть это адрес msg[1]. Далее load загружает байт по этому адресу, получая символ 'e' (второй символ строки "Hello").  
5. Передача символа в printf  
```
%5 = sext i8 %4 to i32
%6 = call i32 (ptr, ...) @printf(ptr noundef @.str, i32 noundef %5)
```
Символ расширяется (sext) до 32 бит, так как printf ожидает int, и затем передаётся в printf. Формат @.str:  
```
@.str = private unnamed_addr constant [4 x i8] c"%c\0A\00", align 1
```
Это строка формата "%c\n".
